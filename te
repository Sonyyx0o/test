-- Я видел фотки, как просто с 
-- другом ты улетела (Ты улетела)
-- Зачем тогда, всё это время, ты 
-- мне пиздела? (Зачем пиздела?)
-- Давай расскажем ему, как 
-- мы ебались прошлой ночью
-- И почему расстались
-- Я не знал, что ты такая стерва
-- Но я навсегда останусь 
-- в твоей жизни первым
-- Давай расскажем ему как 
-- мы ебались прошлой ночью
-- И почему расстались
-- Я не знал, что ты такая стерва
-- Но я навсегда останусь 
-- в твоей жизни первым.
-- Nocthra  coder(god) @Sonyyx
local pui = require('gamesense/pui')

local icons = {
    home = "▦",
    target = "▦", 
    menu = "▦",
    star = "▤"
}

nocthra = {}
nocthra.ui = {}
nocthra.macros = {}
nocthra.macros.color_main = '\aFFFFFF90'
nocthra.macros.color_accent = '\aA1A1A190'
nocthra.macros.color_special = '\a7D5FFEFF'
nocthra.macros.color_gray = '\a808080FF'
nocthra.macros.color_white = '\aFFFFFFFF'

-- анимация титла
local function create_animated_text(text, r, g, b)
    local colors = {}
    for i = 1, #text do
        local alpha = 255 * math.abs(math.cos(1.6 * math.pi * globals.curtime() / 2.5 + i * 4 / 30))
        table.insert(colors, {r, g, b, alpha})
    end
    
    local result = ""
    for i = 1, #text do
        local char = text:sub(i, i)
        local color_hex = string.format('%.2x%.2x%.2x%.2x', 
            colors[i][1], colors[i][2], colors[i][3], colors[i][4])
        result = result .. string.format("\a%s%s", color_hex, char)
    end
    
    return result
end

local function normalize_yaw(yaw)
    while yaw > 180 do yaw = yaw - 360 end
    while yaw < -180 do yaw = yaw + 360 end
    return yaw
end

-- Инициализируем anti_brute таблицу
local anti_brute = {
    current_offset = 0,
    active_until = 0,
    last_print = 0
}

local ref = {
    enabled = ui.reference('AA', 'Anti-aimbot angles', 'Enabled'),
    yawbase = ui.reference('AA', 'Anti-aimbot angles', 'Yaw base'),
    pitch = { ui.reference('AA', 'Anti-aimbot angles', 'Pitch') },
    yaw = { ui.reference('AA', 'Anti-aimbot angles', 'Yaw') }, 
    yawjitter = { ui.reference('AA', 'Anti-aimbot angles', 'Yaw jitter') },
    body_yaw = { ui.reference('AA', 'Anti-aimbot angles', 'Body yaw') },
    freestanding = { ui.reference('AA', 'Anti-aimbot angles', 'Freestanding') },
    leg_movement = ui.reference('AA', 'Other', 'Leg movement'),
    on_shot_aa = ui.reference('AA', 'Other', 'On shot anti-aim'),
    freestanding_body_yaw = ui.reference('AA', 'Anti-aimbot angles', 'Freestanding body yaw'),
    edge_yaw = ui.reference('AA', 'Anti-aimbot angles', 'Edge yaw'),
    roll = ui.reference('AA', 'Anti-aimbot angles', 'Roll'),
    fakelag_enabled = ui.reference('AA', 'Fake lag', 'Enabled'),
    fakelag_amount = ui.reference('AA', 'Fake lag', 'Amount'),
    fakelag_limit = ui.reference('AA', 'Fake lag', 'Limit'),
    fakelag_variance = ui.reference('AA', 'Fake lag', 'Variance'),
    slow_motion = ui.reference('AA', 'Other', 'Slow motion'),
    fake_peek = ui.reference('AA', 'Other', 'Fake peek'),
    double_tap = {ui.reference('RAGE', 'Aimbot', 'Double tap')},
}

local aa_enable_ref = ui.reference("AA", "Anti-aimbot angles", "Enabled")
local pitch_mode_ref, pitch_offset_ref = ui.reference("AA", "Anti-aimbot angles", "Pitch")
local yaw_base_ref = ui.reference("AA", "Anti-aimbot angles", "Yaw base")
local yaw_mode_ref, yaw_offset_ref = ui.reference("AA", "Anti-aimbot angles", "Yaw")
local yaw_jitter_mode_ref, yaw_jitter_offset_ref = ui.reference("AA", "Anti-aimbot angles", "Yaw jitter")
local body_yaw_ref, body_yaw_limit_ref = ui.reference("AA", "Anti-aimbot angles", "Body yaw")
local freestanding_ref = ui.reference("AA", "Anti-aimbot angles", "Freestanding")
local edge_yaw_ref = ui.reference("AA", "Anti-aimbot angles", "Edge yaw")

-- Добавляем недостающие функции ПОСЛЕ объявления ref
local function is_double_tap_active()
    return ui.get(ref.double_tap[1]) and ui.get(ref.double_tap[2])
end

local function handle_avoid_backstab()
    return false
end

local function handle_safe_head()
end

local function handle_freestanding()
end

local function handle_slow_motion()
end

-- UI элементы
nocthra.ui.main_group = pui.group('AA', 'Fake Lag')
nocthra.ui.animated_title = nocthra.ui.main_group:label("Nocthra - Release")

-- Табы
nocthra.ui.tab_selector = nocthra.ui.main_group:combobox(
    nocthra.macros.color_main .. 'Select Tab', 
    {
        icons.home .. ' Home', 
        icons.menu .. ' Misc',
        icons.target .. ' AA'
    }
)

nocthra.ui.last_update = nocthra.ui.main_group:label(nocthra.macros.color_gray .. '\v•\r Last Update:12.10.25')

-- Home таб элементы
nocthra.ui.config_group = nocthra.ui.main_group:combobox(nocthra.macros.color_main .. 'Config Manager', {'Load', 'Save', 'Delete'})
nocthra.ui.config_name = nocthra.ui.main_group:textbox(nocthra.macros.color_accent .. 'Config Name')
nocthra.ui.discord = nocthra.ui.main_group:button("\a008EFFFFDiscord\r server", function()
    panorama.loadstring(panorama.open("CSGOHud").SteamOverlayAPI.OpenExternalBrowserURL("https://discord.gg/UWdJrrQbvd"))()
end)
nocthra.ui.youtube = nocthra.ui.main_group:button("\aD97B7FFFYou\rTube", function()
    panorama.loadstring(panorama.open("CSGOHud").SteamOverlayAPI.OpenExternalBrowserURL("https://www.youtube.com/@kennex1337"))()
end)

-- Misc таб элементы
nocthra.ui.misc_group = nocthra.ui.main_group:multiselect(nocthra.macros.color_main .. 'Miscellaneous', {'Screen indicator', 'Logs', 'Hitrate', 'Resolver', 'Predict'})

-- AA таб элементы
nocthra.ui.aa_category = nocthra.ui.main_group:combobox(
    nocthra.macros.color_main .. 'AA Category', 
    {
        'Anti-Aim',
        'Defensive Builder'
    }
)
nocthra.ui.aa_states_group = nocthra.ui.main_group:combobox(nocthra.macros.color_main .. 'AA States', {'Standing', 'Moving', 'Air', 'Air Duck', 'Crouching', 'Crouching Moving', 'Slowwalk'})
nocthra.ui.defensive_builder_enabled = nocthra.ui.main_group:checkbox(nocthra.macros.color_gray .. 'Defensive Builder')
nocthra.ui.anti_bruteforce_checkbox = nocthra.ui.main_group:checkbox(nocthra.macros.color_main .. "Anti-Bruteforce")

-- Defensive элементы
nocthra.defensive_elements = {}
local defensive_states = {'Standing', 'Moving', 'Air', 'Air Duck', 'Crouching', 'Crouching Moving', 'Slowwalk'}

for _, state_name in ipairs(defensive_states) do
    nocthra.defensive_elements[state_name] = {
        defensive_pitch = nocthra.ui.main_group:combobox(
            nocthra.macros.color_accent .. state_name .. nocthra.macros.color_white .. ' ~ Pitch Defensive',
            {'off', 'default', 'up', 'down', 'minimal', 'random'}
        ),
        defensive_yaw_override = nocthra.ui.main_group:combobox(
            nocthra.macros.color_accent .. state_name .. nocthra.macros.color_white .. ' ~ Yaw Override', 
            {'off', '180', 'spin', 'static', '180 Z'}
        ),
        defensive_yaw_jitter = nocthra.ui.main_group:combobox(
            nocthra.macros.color_accent .. state_name .. nocthra.macros.color_white .. ' ~ Defensive Yaw Jitter',
            {'off', 'center', 'offset', 'random', 'skitter'}
        )
    }
    
    for _, element in pairs(nocthra.defensive_elements[state_name]) do
        element:set_visible(false)
    end
end

-- AA States настройки
nocthra.aa_states_settings = {
    ['Standing'] = { 
        pitch_mode = 'Off', 
        yaw_base = 'Local view', 
        yaw_mode = 'Off', 
        yaw_jitter = 'Off',
        body_yaw_mode = 'Static',
        body_yaw_value = 0,
        defensive_enabled = false,
        defensive_pitch = 'off',
        defensive_yaw = 'off',
        defensive_jitter = 'off'
    },
    ['Moving'] = { 
        pitch_mode = 'Off', 
        yaw_base = 'Local view', 
        yaw_mode = 'Off', 
        yaw_jitter = 'Off',
        body_yaw_mode = 'Static',
        body_yaw_value = 0,
        defensive_enabled = false,
        defensive_pitch = 'off',
        defensive_yaw = 'off',
        defensive_jitter = 'off'
    },
    ['Air'] = { 
        pitch_mode = 'Off', 
        yaw_base = 'Local view', 
        yaw_mode = 'Off', 
        yaw_jitter = 'Off',
        body_yaw_mode = 'Static',
        body_yaw_value = 0,
        defensive_enabled = false,
        defensive_pitch = 'off',
        defensive_yaw = 'off',
        defensive_jitter = 'off'
    },
    ['Air Duck'] = { 
        pitch_mode = 'Off', 
        yaw_base = 'Local view', 
        yaw_mode = 'Off', 
        yaw_jitter = 'Off',
        body_yaw_mode = 'Static',
        body_yaw_value = 0,
        defensive_enabled = false,
        defensive_pitch = 'off',
        defensive_yaw = 'off',
        defensive_jitter = 'off'
    },
    ['Crouching'] = { 
        pitch_mode = 'Off', 
        yaw_base = 'Local view', 
        yaw_mode = 'Off', 
        yaw_jitter = 'Off',
        body_yaw_mode = 'Static',
        body_yaw_value = 0,
        defensive_enabled = false,
        defensive_pitch = 'off',
        defensive_yaw = 'off',
        defensive_jitter = 'off'
    },
    ['Crouching Moving'] = { 
        pitch_mode = 'Off', 
        yaw_base = 'Local view', 
        yaw_mode = 'Off', 
        yaw_jitter = 'Off',
        body_yaw_mode = 'Static',
        body_yaw_value = 0,
        defensive_enabled = false,
        defensive_pitch = 'off',
        defensive_yaw = 'off',
        defensive_jitter = 'off'
    },
    ['Slowwalk'] = { 
        pitch_mode = 'Off', 
        yaw_base = 'Local view', 
        yaw_mode = 'Off', 
        yaw_jitter = 'Off',
        body_yaw_mode = 'Static',
        body_yaw_value = 0,
        defensive_enabled = false,
        defensive_pitch = 'off',
        defensive_yaw = 'off',
        defensive_jitter = 'off'
    }
}

-- AA элементы
nocthra.aa_elements = {}
for state_name, state_data in pairs(nocthra.aa_states_settings) do
    nocthra.aa_elements[state_name] = {
        pitch_mode = nocthra.ui.main_group:combobox(
            nocthra.macros.color_gray .. state_name .. nocthra.macros.color_white .. ' ~ Pitch', 
            {'Off', 'Down', 'Up', 'Minimal', 'Random'}
        ),
        yaw_base = nocthra.ui.main_group:combobox(
            nocthra.macros.color_gray .. state_name .. nocthra.macros.color_white .. ' ~ Yaw Base', 
            {'At targets', 'Local view'}
        ),
        yaw_mode = nocthra.ui.main_group:combobox(
            nocthra.macros.color_gray .. state_name .. nocthra.macros.color_white .. ' ~ Yaw', 
            {'Off', '180', 'Spin', 'Static'}
        ),
        yaw_jitter = nocthra.ui.main_group:combobox(
            nocthra.macros.color_gray .. state_name .. nocthra.macros.color_white .. ' ~ Yaw Jitter', 
            {'Off', 'Offset', 'Center', 'Opposite', 'Skitter', 'Random'}
        ),
        body_yaw_mode = nocthra.ui.main_group:combobox(
            nocthra.macros.color_gray .. state_name .. nocthra.macros.color_white .. ' ~ Body Yaw', 
            {'Static', 'Jitter', 'Opposite'}
        ),
        body_yaw_value = nocthra.ui.main_group:slider(
            nocthra.macros.color_gray .. state_name .. nocthra.macros.color_white .. ' ~ Body Yaw Value', 
            -60, 60, 0, true, '°'
        )
    }
    
    nocthra.aa_elements[state_name].pitch_mode:set(state_data.pitch_mode)
    nocthra.aa_elements[state_name].yaw_base:set(state_data.yaw_base)
    nocthra.aa_elements[state_name].yaw_mode:set(state_data.yaw_mode)
    nocthra.aa_elements[state_name].yaw_jitter:set(state_data.yaw_jitter)
    nocthra.aa_elements[state_name].body_yaw_mode:set(state_data.body_yaw_mode)
    nocthra.aa_elements[state_name].body_yaw_value:set(state_data.body_yaw_value)
    
    for _, element in pairs(nocthra.aa_elements[state_name]) do
        element:set_visible(false)
    end
end

nocthra.defensive_states = {
    double_tap_active = false
}

-- Функция для ближайшей точки
local function get_closest_point(A, B, P)
    local a_to_p = { P[1] - A[1], P[2] - A[2] }
    local a_to_b = { B[1] - A[1], B[2] - A[2] }

    local atb2 = a_to_b[1]^2 + a_to_b[2]^2
    if atb2 == 0 then return A end

    local atp_dot_atb = a_to_p[1] * a_to_b[1] + a_to_p[2] * a_to_b[2]
    local t = math.max(0, math.min(1, atp_dot_atb / atb2))

    return { A[1] + a_to_b[1] * t, A[2] + a_to_b[2] * t }
end

-- Брутфорс система
client.set_event_callback("bullet_impact", function(e)
    if not nocthra.ui.anti_bruteforce_checkbox:get() then
        anti_brute.current_offset = 0
        return
    end
    local ent = client.userid_to_entindex(e.userid)
    if entity.is_enemy(ent) then
        local ent_origin = { entity.get_prop(ent, "m_vecOrigin") }
        local local_head = { entity.hitbox_position(entity.get_local_player(), 0) }
        
        local closest = get_closest_point(
            { ent_origin[1], ent_origin[2] },
            { e.x, e.y },
            { local_head[1], local_head[2] }
        )
        
        local delta = (local_head[1] - closest[1])^2 + (local_head[2] - closest[2])^2
        if delta <= 1600 then
            anti_brute.active_until = globals.realtime() + 10
            anti_brute.current_offset = math.random(-8, -1)
            
            if globals.realtime() - anti_brute.last_print > 1 then
                anti_brute.last_print = globals.realtime()
            end
        end
    end
end)

local elements_hidden = false

-- Функции скрытия/показа элементов
local function hide_all_aa_elements()
    for name, element in pairs(ref) do
        if type(element) == "table" then
            for i = 1, #element do
                if ui.get(element[i]) ~= nil then
                    ui.set_visible(element[i], false)
                end
            end
        else
            if ui.get(element) ~= nil then
                ui.set_visible(element, false)
            end
        end
    end
    elements_hidden = true
end

local function show_all_aa_elements()
    for name, element in pairs(ref) do
        if type(element) == "table" then
            for i = 1, #element do
                if ui.get(element[i]) ~= nil then
                    ui.set_visible(element[i], true)
                end
            end
        else
            if ui.get(element) ~= nil then
                ui.set_visible(element, true)
            end
        end
    end
    elements_hidden = false
end

local function check_and_hide_elements()
    if not elements_hidden then return end
    for name, element in pairs(ref) do
        if type(element) == "table" then
            for i = 1, #element do
                if ui.get(element[i]) ~= nil then
                    ui.set_visible(element[i], false)
                end
            end
        else
            if ui.get(element) ~= nil then
                ui.set_visible(element, false)
            end
        end
    end
end

-- Jitter система
local jitter_state = {
    last_tick = 0,
    current_angle = 0,
    direction = 1,
    opposite_state = false,
    skitter_accumulator = 0
}

local JITTER_AMOUNT = 60
local JITTER_SPEED = 3
local JITTER_OFFSET = 30

-- Yaw jitter
local function handle_yaw_jitter(jitter_mode)
    if jitter_mode == 'Off' then
        ui.set(yaw_jitter_mode_ref, 'Off')
        return
    end
    
    local tick_count = globals.tickcount()
    
    if jitter_mode == 'Center' then
        ui.set(yaw_jitter_mode_ref, 'Center')
    elseif jitter_mode == 'Offset' then
        ui.set(yaw_jitter_mode_ref, 'Offset')
        if tick_count - jitter_state.last_tick >= JITTER_SPEED then
            jitter_state.last_tick = tick_count
            jitter_state.direction = jitter_state.direction * -1
            if yaw_jitter_offset_ref then
                ui.set(yaw_jitter_offset_ref, jitter_state.direction > 0 and JITTER_OFFSET or -JITTER_OFFSET)
            end
        end
    elseif jitter_mode == 'Opposite' then
        ui.set(yaw_jitter_mode_ref, 'Offset')
        if tick_count - jitter_state.last_tick >= JITTER_SPEED * 2 then
            jitter_state.last_tick = tick_count
            jitter_state.opposite_state = not jitter_state.opposite_state
            if yaw_jitter_offset_ref then
                ui.set(yaw_jitter_offset_ref, jitter_state.opposite_state and JITTER_AMOUNT or -JITTER_AMOUNT)
            end
        end
    elseif jitter_mode == 'Skitter' then
        ui.set(yaw_jitter_mode_ref, 'Offset')
        if tick_count - jitter_state.last_tick >= 1 then
            jitter_state.last_tick = tick_count
            jitter_state.skitter_accumulator = (jitter_state.skitter_accumulator + 1) % 4
            local skitter_values = {10, -8, 12, -9}
            if yaw_jitter_offset_ref then
                ui.set(yaw_jitter_offset_ref, skitter_values[jitter_state.skitter_accumulator + 1])
            end
        end
    elseif jitter_mode == 'Random' then
        ui.set(yaw_jitter_mode_ref, 'Offset')
        if tick_count - jitter_state.last_tick >= JITTER_SPEED then
            jitter_state.last_tick = tick_count
            local random_angle = math.random(-JITTER_AMOUNT, JITTER_AMOUNT)
            if yaw_jitter_offset_ref then
                ui.set(yaw_jitter_offset_ref, random_angle)
            end
        end
    end
end

-- Defensive yaw jitter
local function handle_defensive_yaw_jitter(jitter_mode)
    if jitter_mode == 'off' then return end
    
    local tick_count = globals.tickcount()
    
    if jitter_mode == 'center' then
        ui.set(yaw_jitter_mode_ref, 'Center')
    elseif jitter_mode == 'offset' then
        ui.set(yaw_jitter_mode_ref, 'Offset')
        if tick_count - jitter_state.last_tick >= JITTER_SPEED then
            jitter_state.last_tick = tick_count
            jitter_state.direction = jitter_state.direction * -1
            if yaw_jitter_offset_ref then
                ui.set(yaw_jitter_offset_ref, jitter_state.direction > 0 and JITTER_OFFSET or -JITTER_OFFSET)
            end
        end
    elseif jitter_mode == 'random' then
        ui.set(yaw_jitter_mode_ref, 'Offset')
        if tick_count - jitter_state.last_tick >= JITTER_SPEED then
            jitter_state.last_tick = tick_count
            local random_angle = math.random(-JITTER_AMOUNT, JITTER_AMOUNT)
            if yaw_jitter_offset_ref then
                ui.set(yaw_jitter_offset_ref, random_angle)
            end
        end
    elseif jitter_mode == 'skitter' then
        ui.set(yaw_jitter_mode_ref, 'Offset')
        if tick_count - jitter_state.last_tick >= 1 then
            jitter_state.last_tick = tick_count
            jitter_state.skitter_accumulator = (jitter_state.skitter_accumulator + 1) % 4
            local skitter_values = {15, -12, 18, -14}
            if yaw_jitter_offset_ref then
                ui.set(yaw_jitter_offset_ref, skitter_values[jitter_state.skitter_accumulator + 1])
            end
        end
    end
end

-- Body yaw
local function handle_body_yaw(body_yaw_mode, body_yaw_value)
    if body_yaw_mode == 'Static' then
        ui.set(body_yaw_ref, 'Static')
        if body_yaw_limit_ref then
            ui.set(body_yaw_limit_ref, body_yaw_value)
        end
    elseif body_yaw_mode == 'Jitter' then
        ui.set(body_yaw_ref, 'Jitter')
        if body_yaw_limit_ref then
            ui.set(body_yaw_limit_ref, body_yaw_value)
        end
    elseif body_yaw_mode == 'Opposite' then
        local tick_count = globals.tickcount()
        if tick_count - jitter_state.last_tick >= JITTER_SPEED * 2 then
            jitter_state.last_tick = tick_count
            jitter_state.opposite_state = not jitter_state.opposite_state
            ui.set(body_yaw_ref, 'Static')
            if body_yaw_limit_ref then
                ui.set(body_yaw_limit_ref, jitter_state.opposite_state and body_yaw_value or -body_yaw_value)
            end
        end
    end
end

-- Defensive pitch
local function handle_defensive_pitch(pitch_mode)
    if pitch_mode == 'off' then
        ui.set(pitch_mode_ref, 'Off')
    elseif pitch_mode == 'default' then
    elseif pitch_mode == 'up' then
        ui.set(pitch_mode_ref, 'Up')
    elseif pitch_mode == 'down' then
        ui.set(pitch_mode_ref, 'Down')
    elseif pitch_mode == 'minimal' then
        ui.set(pitch_mode_ref, 'Minimal')
    elseif pitch_mode == 'random' then
        ui.set(pitch_mode_ref, 'Random')
    end
end

-- Yaw Override
local function handle_defensive_yaw_override(yaw_mode)
    if yaw_mode == 'off' then
    elseif yaw_mode == '180' then
        ui.set(yaw_mode_ref, '180')
    elseif yaw_mode == 'spin' then
        ui.set(yaw_mode_ref, 'Spin')
    elseif yaw_mode == 'static' then
        ui.set(yaw_mode_ref, 'Static')
    elseif yaw_mode == '180 Z' then
        ui.set(yaw_mode_ref, '180')
    end
end

-- Defensive параметры
local function apply_defensive_parameters(current_state)
    if not nocthra.ui.defensive_builder_enabled:get() or not is_double_tap_active() then
        return false
    end
    
    local state_data = nocthra.aa_states_settings[current_state]
    if not state_data then return false end
    
    local pitch_mode = state_data.defensive_pitch
    local yaw_override = state_data.defensive_yaw
    local yaw_jitter = state_data.defensive_jitter
    
    handle_defensive_pitch(pitch_mode)
    handle_defensive_yaw_override(yaw_override)
    handle_defensive_yaw_jitter(yaw_jitter)
    
    return true
end

-- Получение состояния игрока
local function get_player_state()
    local local_player = entity.get_local_player()
    if not local_player then return 'Standing' end
    
    local velocity_x, velocity_y, velocity_z = entity.get_prop(local_player, "m_vecVelocity")
    local speed = math.sqrt(velocity_x * velocity_x + velocity_y * velocity_y)
    local flags = entity.get_prop(local_player, "m_fFlags")
    
    local ducking = bit.band(flags, 4) == 4
    
    if bit.band(flags, 1) == 0 then
        if ducking then
            return 'Air Duck'
        else
            return 'Air'
        end
    elseif ducking then
        if speed > 5 then
            return 'Crouching Moving'
        else
            return 'Crouching'
        end
    elseif speed < 5 then
        return 'Standing'
    elseif speed < 100 then
        return 'Slowwalk'
    else
        return 'Moving'
    end
end

-- Применение AA параметров
local function apply_aa_parameters(state)
    local state_data = nocthra.aa_states_settings[state]
    if not state_data then return end
    
    if nocthra.ui.anti_bruteforce_checkbox:get() and globals.realtime() < anti_brute.active_until then
        ui.set(yaw_mode_ref, 'Static')
        ui.set(yaw_offset_ref, anti_brute.current_offset)
        ui.set(yaw_base_ref, 'At targets')
        ui.set(yaw_jitter_mode_ref, 'Off')
        ui.set(pitch_mode_ref, 'Off')
        return
    end
    
    if handle_avoid_backstab() then
        return
    end
    
    handle_safe_head()
    handle_freestanding()
    handle_slow_motion()
    
    ui.set(aa_enable_ref, true)
    
    if nocthra.aa_elements[state] then
        local pitch_mode = nocthra.aa_elements[state].pitch_mode:get()
        ui.set(pitch_mode_ref, pitch_mode)
        state_data.pitch_mode = pitch_mode
    end
    
    if nocthra.aa_elements[state] then
        local yaw_base_mode = nocthra.aa_elements[state].yaw_base:get()
        ui.set(yaw_base_ref, yaw_base_mode)
        state_data.yaw_base = yaw_base_mode
    end
    
    if nocthra.aa_elements[state] then
        local yaw_mode = nocthra.aa_elements[state].yaw_mode:get()
        ui.set(yaw_mode_ref, yaw_mode)
        state_data.yaw_mode = yaw_mode
    end
    
    if nocthra.aa_elements[state] then
        local yaw_jitter_mode = nocthra.aa_elements[state].yaw_jitter:get()
        handle_yaw_jitter(yaw_jitter_mode)
        state_data.yaw_jitter = yaw_jitter_mode
    end
    
    if nocthra.aa_elements[state] then
        local body_yaw_mode = nocthra.aa_elements[state].body_yaw_mode:get()
        local body_yaw_value = nocthra.aa_elements[state].body_yaw_value:get()
        handle_body_yaw(body_yaw_mode, body_yaw_value)
        state_data.body_yaw_mode = body_yaw_mode
        state_data.body_yaw_value = body_yaw_value
    end
end

-- Обновление видимости
local function update_all_visibility()
    local current_tab_with_icon = nocthra.ui.tab_selector:get()
    local current_tab = current_tab_with_icon:sub(4)
    
    local is_home = (current_tab == 'Home')
    local is_misc = (current_tab == 'Misc') 
    local is_aa = (current_tab == 'AA')

    -- Home таб
    nocthra.ui.config_group:set_visible(is_home)
    nocthra.ui.config_name:set_visible(is_home)
    nocthra.ui.discord:set_visible(is_home)
    nocthra.ui.youtube:set_visible(is_home)
    nocthra.ui.last_update:set_visible(is_home)

    -- Misc таб
    nocthra.ui.misc_group:set_visible(is_misc)

    -- AA таб
    nocthra.ui.aa_category:set_visible(is_aa)
    nocthra.ui.aa_states_group:set_visible(is_aa)
    nocthra.ui.defensive_builder_enabled:set_visible(is_aa)
    nocthra.ui.anti_bruteforce_checkbox:set_visible(is_aa)
    
    local current_state = nocthra.ui.aa_states_group:get()
    local defensive_enabled = nocthra.ui.defensive_builder_enabled:get()
    local current_category = nocthra.ui.aa_category:get()
    local is_defensive = (current_category == 'Defensive Builder')
    
    for state_name, elements in pairs(nocthra.aa_elements) do
        local visible = is_aa and (current_state == state_name) and not is_defensive
        for _, element in pairs(elements) do
            element:set_visible(visible)
        end
    end
    
    for state_name, elements in pairs(nocthra.defensive_elements) do
        local visible = is_aa and is_defensive and defensive_enabled and (current_state == state_name)
        for _, element in pairs(elements) do
            element:set_visible(visible)
        end
    end
end

-- Анимация заголовка
local function update_animated_title()
    local animated_text = create_animated_text("Nocthra - Release", 0, 150, 200)
    nocthra.ui.animated_title:set(animated_text)
end

-- Сохранение/загрузка defensive настроек
local function save_defensive_settings(state_name)
    if not nocthra.defensive_elements[state_name] then return end
    local state_data = nocthra.aa_states_settings[state_name]
    if not state_data then return end
    
    state_data.defensive_pitch = nocthra.defensive_elements[state_name].defensive_pitch:get()
    state_data.defensive_yaw = nocthra.defensive_elements[state_name].defensive_yaw_override:get()
    state_data.defensive_jitter = nocthra.defensive_elements[state_name].defensive_yaw_jitter:get()
end

local function load_defensive_settings(state_name)
    if not nocthra.defensive_elements[state_name] then return end
    local state_data = nocthra.aa_states_settings[state_name]
    if not state_data then return end
    
    nocthra.defensive_elements[state_name].defensive_pitch:set(state_data.defensive_pitch)
    nocthra.defensive_elements[state_name].defensive_yaw_override:set(state_data.defensive_yaw)
    nocthra.defensive_elements[state_name].defensive_yaw_jitter:set(state_data.defensive_jitter)
end

-- Инициализация
hide_all_aa_elements()
for state_name, _ in pairs(nocthra.aa_states_settings) do
    load_defensive_settings(state_name)
end

-- Callbacks
nocthra.ui.tab_selector:set_callback(update_all_visibility)
nocthra.ui.aa_category:set_callback(update_all_visibility)
nocthra.ui.aa_states_group:set_callback(update_all_visibility)
nocthra.ui.defensive_builder_enabled:set_callback(update_all_visibility)

for state_name, elements in pairs(nocthra.defensive_elements) do
    elements.defensive_pitch:set_callback(function() save_defensive_settings(state_name) end)
    elements.defensive_yaw_override:set_callback(function() save_defensive_settings(state_name) end)
    elements.defensive_yaw_jitter:set_callback(function() save_defensive_settings(state_name) end)
end

-- Event callbacks
client.set_event_callback('paint', function()
    local player_state = get_player_state()
    apply_aa_parameters(player_state)
    if is_double_tap_active() then
        apply_defensive_parameters(player_state)
    end
    update_all_visibility()
end)

client.set_event_callback('paint_ui', function()
    check_and_hide_elements()
    update_animated_title()
end)

client.set_event_callback('shutdown', show_all_aa_elements)

update_all_visibility()
